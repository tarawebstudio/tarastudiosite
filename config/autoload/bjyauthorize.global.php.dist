<?php
return array(
'bjyauthorize' => array(
// Установите роль 'guest', как роль по умолчанию
// (она должна быть также задана в секции role provider).
                'default_role' => 'guest',
                
/* Модуль использует мета-роли, которые могут наследоваться от любых ролей,
* которые должны быть применены к активному пользователю.
* Провайдер идентификации (identity provider) предоставляет информацию о том,
* какие роли "с собственной идентичностью" (т.е., не guest) унаследованы
* (текущей ролью пользователя).
*
* для ZfcUser это должен быть провайдер идентификации по умолчанию:
*/
     'identity_provider' => 'BjyAuthorize\Provider\Identity\ZfcUserZendDb',
/* Если у вас есть только роль по умолчанию (гость, не требующая
* аутентификации) и роль, требующая аутентификации, вы можете использовать
* 'AuthenticationIdentityProvider', чтобы предоставлять или разрешать
* доступ на основании того, выполнял ли пользователь вход в систему (login),
* или нет. (Т.е. в этом случае может быть всего две роли в системе, скажем,
* гость и админ, или же гость и пользователь. Если вас это не устраивает, и
* необходимо более, чем две роли, используйте провайдер идентификации по
* умолчанию, как показано выше для ZfcUser.)
*
* 'default_role'=> 'guest',// not authenticated
*  'authenticated_role' => 'user', // authenticated
* 'identity_provider' => 'BjyAuthorize\Provider\Identity\AuthenticationIdentityProvider',
*/
/* Провайдеры ролей (role providers) просто предоставляют список ролей,
* которые должны быть в системе, в экземпляр Zend\Acl. Модуль предоставляет
* два провайдера, один используется для указания ролей с помощью файла
* конфигурации (который мы сейчас и заполняем), а другой загружает роли
* из базы данных, используя адаптер Zend\Db. Для второго провайдера
* необходимо самостоятельно создать в базе данных необходимую вам
* конфигурацию ролей. В этом вам поможет цветная схема выше в этой главе.
*/
'role_providers' => array(
/* здесь 'guest' и 'user' определены, как роли верхнего уровня, а
* 'admin' наследуется от 'user'
*
* 'BjyAuthorize\Provider\Role\Config' => array(
*'guest' => array(),
*'user' => array('children' => array(
*
*'admin' => array(),
)),
* ),
*/
// здесь роли загружаются из таблицы user_role базы данных,
// вы можете указать собственную таблицу, главное, чтобы соблюдались
// типы данных для столбцов: user_role(role_id(varchar), parent(varchar))  
//Я смотрю, чтобы программисты не скучали, автор иногда меняет
// имена столбцов в schema.sql модуля, так что будьте внимательны.

'BjyAuthorize\Provider\Role\ZendDb' => array(
'table' => 'user_role',
'role_id_field' => 'roleId',
'parent_role_field' => 'parent_id',
),
// При использовании Doctrine это позволит загружать роли
// из сервиса 'BjyAuthorize\Provider\Role\Doctrine'
'BjyAuthorize\Provider\Role\Doctrine' => array(),
),
// провайдер ресурсов (resource provider) предоставляет список ресурсов
// в ACL, как и роли, они могут быть иерархическими.
// Заметьте, что ресурсы на сегодняшний день не хранятся в базе данных, и
// и считываются только из этой конфигурации.
'resource_providers' => array(
'BjyAuthorize\Provider\Resource\Config' => array(
'pants' => array(), // pants – брюки, читай пример ниже
),
),
/* здесь могут быть указаны правила в формате:
* array(roles (array), resource, [privilege (array|string), assertion])
*
* Утверждения (assertions) должны быть загружены с помощью сервис-менеджера
* и должны реализовывать интерфейс Zend\Acl\Assertion\AssertionInterface.
* *если вы используете утверждения, определите их в сервис-менеджере!*
* Мы еще не рассматривали утверждения, эта тема будет раскрыта
* в расширенном использовании.
*/


'rule_providers' => array(
               'BjyAuthorize\Provider\Rule\Config' => array(
                 'allow' => array(
// позволяет гостям и пользователям (и администраторам, по наследству)
// привелегию "носить" (wear) для ресурса "брюки" (pants)
                           array(array('guest', 'user'), 'pants', 'wear')
                 ),
// Не смешивайте правила разрешения/запрещения (allow/deny), если вы
// используете наследование для ролей.
// это может привести к непредсказуемым ошибкам.
                'deny' => array(
// ...
                  ),
             ),
      ), //rule_providers
      



/* В настоящее время защита (guards) существует только для контроллеров и маршрутов:
*
* Обращаю ваше внимание, если вы не поняли этот момент, поскольку это реализация
* шаблона "фасад", то ресурсы, привилегии и разрешения, которые мы задавали ранее,
* просто передаются в ACL. Реальная защита контроллеров и маршрутов указывается
* здесь. Поскольку защите подлежат только маршруты и контроллеры, возможно, скажем,
* где-то в шаблоне представления нам нужно будет проверить разрешения на доступ к
* ресурсу и в зависимости от того, что вернет isAllowed(), показывать это
* пользователю, или нет. И эти правила мы можем как раз указать в предыдущих
* пунктах. В этом же разделе указываются параметры автоматической защиты.
*
* Рассмотрите возможности включения защиты для контроллеров или маршрутов,
* в зависимости от того, что именно вам необходимо.
*/
'guards' => array(
/* Если этот защитник (guard) указан здесь (т.е., если он включен), он
* будет блокировать доступ ко всем контроллерам и действиям, которые
* здесь не указаны. Вы можете опустить ключ 'action', чтобы предоставить
* доступ ко всему контроллеру.
*/
        'BjyAuthorize\Guard\Controller' => array(
                   array('controller' => 'index', 'action' => 'index', 'roles' => array('guest','user')),
                   array('controller' => 'index', 'action' => 'stuff','roles' => array('user')),
// Вы можете также задать массив действий или массив контроллеров (или то и
// другое), чтобы позволить для "guest" и "admin" получить доступ к действиям
// "list" и "manage" для контроллеров "index", "static" и "console"
                   array(
                          'controller' => array('index', 'static', 'console'),
                          'action' => array('list', 'manage'),
                          'roles' => array('guest', 'admin')
                        ),
                   array(
                             'controller' => array('search', 'administration'),
                             'roles' => array('staffer', 'admin') // staffer (англ.) - сотрудник
                         ),
                  array('controller' => 'zfcuser', 'roles' => array()),
         // Ниже - действие по умолчанию index для ZendSkeletonApplication
         // array('controller' => 'Application\Controller\Index',
           //'roles' => array('guest', 'user')),
    ),
    
    
    
    
/* Если этот защитник указан здесь (т.е., если он включен), он будет
* блокировать доступ ко всем маршрутам, которые здесь не указаны.
*/
'BjyAuthorize\Guard\Route' => array(                   
array('route' => 'zfcuser', 'roles' => array('user')),
array('route' => 'zfcuser/logout', 'roles' => array('user')),
array('route' => 'zfcuser/login', 'roles' => array('guest')),
array('route' => 'zfcuser/register', 'roles' => array('guest')),
// Ниже - действие по умолчанию index для ZendSkeletonApplication
array('route' => 'home', 'roles' => array('guest', 'user')),
),
),
),
);
